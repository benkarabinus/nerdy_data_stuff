# THE CORRECTION: I'm filling in this code chunk for you to ensure that you have the outcome in a form that will work for both the logistic regression models and the deviance computation you will do in Question 7. Run this chunk as it is.
pew.start$worse[pew.start$LIFE==1] <- 0
pew.start$worse[pew.start$LIFE==3] <- 0
pew.start$worse[pew.start$LIFE==2] <- 1
# display the frequencies of the original and recoded outcome
table(pew.start$LIFE, exclude = NULL)
table(pew.start$worse, exclude = NULL)
# re-code variables
#pew.start$worse <- as.factor(pew.start$worse)
pew.start$age    <- as.numeric(pew.start$AGE)
pew.start$income  <- as.numeric(pew.start$PPINCIMP)
pew.start$reg4_factor <- as.factor(pew.start$PPREG4)
pew.start$work_factor <- as.factor(pew.start$PPWORK)
pew.start$gender_factor <- as.factor(pew.start$PPGENDER)
pew.start$eth_factor <- as.factor(pew.start$PPETHM)
pew.start$ideo_factor <- as.factor(pew.start$IDEO)
pew.start$edu_factor <- as.factor(pew.start$PPEDUCAT)
pew.start$know_factor <- as.factor(pew.start$KNOWLEDGE)
pew.start$enjoy_factor <- as.factor(pew.start$ENJOY)
pew.start$snsuse_factor <- as.factor(pew.start$SNSUSE)
pew.start$snsfreqrecode_factor <- as.factor(pew.start$SNSFREQ_recoded)
# check data structure
str(pew.start)
# create new dataframe for analysis
pew3 <- dplyr::select(pew.start, worse, age, income, reg4_factor, work_factor,             gender_factor, eth_factor, ideo_factor, edu_factor, know_factor,
enjoy_factor, snsuse_factor, snsfreqrecode_factor)
# print data structure
str(pew3)
# save the number of rows in pew3
n <- nrow(pew3)
# set seed (reproducable)
set.seed(123456)
Sixty.twenty.twenty <- rep(0:2,c(round(n*.2),round(n*.2),n-2*round(n*.2)))
table(Sixty.twenty.twenty)
Seventy.fifteen.fifteen <- rep(0:2,c(round(n*.15),round(n*.15),n-2*round(n*.15)))
table(Seventy.fifteen.fifteen)
Eighty.ten.ten <- rep(0:2,c(round(n*.10),round(n*.10),n-2*round(n*.10)))
table(Eighty.ten.ten)
Ninety.five.five <- rep(0:2,c(round(n*.05),round(n*.05),n-2*round(n*.05)))
table(Ninety.five.five)
# create random sample of int 0-2, poroportions 70, 15, 15
tvt2 <- sample(rep(0:2,c(round(n*.15),round(n*.15),n-2*round(n*.15))))
# subset rows by sample int 0-2 for train validate test
dat.train<-pew3[tvt2==2,]
dat.valid<-pew3[tvt2==1,]
dat.test<-pew3[tvt2==0,]
# create the null model
model.null <-glm(worse~1,data=dat.train,family="binomial")
# create formula for forward model selection (scope)
fwd_fmla <- as.formula(str_c("worse ~ ",
str_c(names(dat.train)[2:(ncol(dat.train))], collapse = "+")))
# sanity check
fwd_fmla
# create the model using automated forward selection
life.fwd <- step(model.null, scope = fwd_fmla, direction = "forward", trace = 1)
# create glm's
model.1 <- glm(worse~income,data=dat.train,family="binomial")
model.2 <- glm(worse~income+edu_factor,data=dat.train,family="binomial")
model.3 <- glm(worse~income+edu_factor+ideo_factor
,data=dat.train,family="binomial")
model.4 <- glm(worse~income+edu_factor+ideo_factor+gender_factor
,data=dat.train,family="binomial")
model.5 <- glm(worse~income+edu_factor+ideo_factor+gender_factor+reg4_factor
,data=dat.train,family="binomial")
model.6 <- glm(worse~income+edu_factor+ideo_factor+gender_factor+reg4_factor+
snsuse_factor
,data=dat.train,family="binomial")
model.7 <- glm(worse~income+edu_factor+ideo_factor+gender_factor+reg4_factor+
snsuse_factor+know_factor
,data=dat.train,family="binomial")
model.8 <- glm(worse~income+edu_factor+ideo_factor+gender_factor+reg4_factor+
snsuse_factor+know_factor+eth_factor
,data=dat.train,family="binomial")
# create valid.dev to calculate model deviance
valid.dev<-function(m.pred, dat.this){
pred.m<-predict(m.pred,dat.this, type="response")
-2*sum(dat.this$worse*log(pred.m)+(1-dat.this$worse)*log(1-pred.m))
}
# convert worse to numeric type for use with deviance function
dat.valid$worse <- as.numeric(as.character(dat.valid$worse))
# Your code for computing the validation-set deviances of each of the candidate models.
dev.1 <- valid.dev(model.1, dat.this = dat.valid)
dev.2 <- valid.dev(model.2, dat.this = dat.valid)
dev.3 <- valid.dev(model.3, dat.this = dat.valid)
dev.4 <- valid.dev(model.4, dat.this = dat.valid)
dev.5 <- valid.dev(model.5, dat.this = dat.valid)
dev.6 <- valid.dev(model.6, dat.this = dat.valid)
dev.7 <- valid.dev(model.7, dat.this = dat.valid)
dev.8 <- valid.dev(model.8, dat.this = dat.valid)
# print deviance for the candidate models
dev.1
dev.2
dev.3
dev.4
dev.5
dev.6
dev.7
dev.8
# convert worse to numeric type for use with deviance function
dat.test$worse <- as.numeric(as.character(dat.test$worse))
# compute deviance
test.dev <- valid.dev(model.3, dat.test)
# print deviance
test.dev
# convert worse back to factor
#dat.test$worse <- as.factor(dat.test$worse)
# create prediction
prediction <- predict(model.2,dat.test,type="response")
# binarize the outcome
prediction <- as.factor(ifelse(prediction > 0.5, 1, 0))
# create the confusion matrix using table function
confusion.matrix <- table(dat.test$worse, prediction,dnn=c("Actual","Predicted"))
# print the confusion matrix
confusion.matrix
# compute accuracy
# true positives and true negatives are on the diagonals
accuracy <- sum(diag(confusion.matrix))/sum(confusion.matrix)
# compute precision
# (true positive/(true positive + false positive))
precision <- confusion.matrix[2,2]/sum(confusion.matrix[,2])
# compute recall
# (true positive/(true positive + false negative)
recall <- confusion.matrix[2,2]/sum(confusion.matrix[2,])
# compute F1 score
F1 <- 2*((precision*recall)/(precision+recall))
knitr::opts_chunk$set(echo = TRUE)
# Load necessary libraries
library(tidyverse)
load("pew_data.RData")
pew2<-dplyr::select(dat,AGE,PPREG4,PPWORK,PPINCIMP,PPGENDER,PPETHM,IDEO,PPEDUCAT,LIFE, KNOWLEDGE,ENJOY,SNSUSE,SNSFREQ)
attributes(pew2$SNSUSE)
table(pew2$SNSUSE, exclude = NULL) # Exclude argument allows for NAs to be displayed and counted
attributes(pew2$SNSFREQ)
table(pew2$SNSFREQ, exclude = NULL)
# create new column using dplyr
pew2 <- pew2 %>%
mutate(SNSFREQ_recoded = ifelse(SNSUSE == 2 & is.na(SNSFREQ),
6 , SNSFREQ))
# original column
table(pew2$SNSFREQ, exclude = NULL)
# transformed column
table(pew2$SNSFREQ_recoded, exclude = NULL)
# create new data set
pew.start <- dplyr::select(pew2, LIFE,SNSUSE,SNSFREQ_recoded,PPREG4,
PPWORK, PPINCIMP,PPGENDER,PPETHM,IDEO,
PPEDUCAT, KNOWLEDGE, ENJOY, AGE)
# print the number of rows in pew.start
nrow(pew.start)
# check the LIFE Variable
attributes(pew.start$LIFE)
table(pew.start$LIFE, exclude = NULL)
# check the SNSUSE variable
attributes(pew.start$SNSUSE)
table(pew.start$SNSUSE, exclude = NULL)
# check the SNSFRQ_recoded variable
#attributes(pew.start$SNSFREQ)
table(pew.start$SNSFREQ_recoded, exclude = NULL)
# check the PPREG4 Variable
attributes(pew.start$PPREG4)
table(pew.start$PPREG4, exclude = NULL)
# check the PPPWORK variable
attributes(pew.start$PPWORK)
table(pew.start$PPWORK, exclude = NULL)
# check the PPINCIMP variable
attributes(pew.start$PPINCIMP)
table(pew.start$PPINCIMP, exclude = NULL)
# check the PPGENDER variable
attributes(pew.start$PPGENDER)
table(pew.start$PPGENDER, exclude = NULL)
# Check the PPETHM variable
attributes(pew.start$PPETHM)
table(pew.start$PPETHM, exclude = NULL)
# check the IDEO variable
attributes(pew.start$IDEO)
table(pew.start$IDEO, exclude = NULL)
# check the PPEDUCAT variable
attributes(pew.start$PPEDUCAT)
table(pew.start$PPEDUCAT, exclude = NULL)
# check the KNOWLEDGE variable
attributes(pew.start$KNOWLEDGE)
table(pew.start$KNOWLEDGE, exclude = NULL)
# check the ENJOY variable
attributes(pew.start$ENJOY)
table(pew.start$ENJOY, exclude = NULL)
# check the AGE variable
attributes(pew.start$AGE)
table(pew.start$AGE, exclude = NULL)
# set -1 and -2  equal to "NA"
pew.start[pew.start == -1| pew.start == -2] <- NA
# drop rows with "NA"
pew.start <- pew.start %>% drop_na()
# count rows in pew.start
nrow(pew.start)
# THE CORRECTION: I'm filling in this code chunk for you to ensure that you have the outcome in a form that will work for both the logistic regression models and the deviance computation you will do in Question 7. Run this chunk as it is.
pew.start$worse[pew.start$LIFE==1] <- 0
pew.start$worse[pew.start$LIFE==3] <- 0
pew.start$worse[pew.start$LIFE==2] <- 1
# display the frequencies of the original and recoded outcome
table(pew.start$LIFE, exclude = NULL)
table(pew.start$worse, exclude = NULL)
# re-code variables
#pew.start$worse <- as.factor(pew.start$worse)
pew.start$age    <- as.numeric(pew.start$AGE)
pew.start$income  <- as.numeric(pew.start$PPINCIMP)
pew.start$reg4_factor <- as.factor(pew.start$PPREG4)
pew.start$work_factor <- as.factor(pew.start$PPWORK)
pew.start$gender_factor <- as.factor(pew.start$PPGENDER)
pew.start$eth_factor <- as.factor(pew.start$PPETHM)
pew.start$ideo_factor <- as.factor(pew.start$IDEO)
pew.start$edu_factor <- as.factor(pew.start$PPEDUCAT)
pew.start$know_factor <- as.factor(pew.start$KNOWLEDGE)
pew.start$enjoy_factor <- as.factor(pew.start$ENJOY)
pew.start$snsuse_factor <- as.factor(pew.start$SNSUSE)
pew.start$snsfreqrecode_factor <- as.factor(pew.start$SNSFREQ_recoded)
# check data structure
str(pew.start)
# create new dataframe for analysis
pew3 <- dplyr::select(pew.start, worse, age, income, reg4_factor, work_factor,             gender_factor, eth_factor, ideo_factor, edu_factor, know_factor,
enjoy_factor, snsuse_factor, snsfreqrecode_factor)
# print data structure
str(pew3)
# save the number of rows in pew3
n <- nrow(pew3)
# set seed (reproducable)
set.seed(123456)
Sixty.twenty.twenty <- rep(0:2,c(round(n*.2),round(n*.2),n-2*round(n*.2)))
table(Sixty.twenty.twenty)
Seventy.fifteen.fifteen <- rep(0:2,c(round(n*.15),round(n*.15),n-2*round(n*.15)))
table(Seventy.fifteen.fifteen)
Eighty.ten.ten <- rep(0:2,c(round(n*.10),round(n*.10),n-2*round(n*.10)))
table(Eighty.ten.ten)
Ninety.five.five <- rep(0:2,c(round(n*.05),round(n*.05),n-2*round(n*.05)))
table(Ninety.five.five)
# create random sample of int 0-2, proportions 70, 15, 15
tvt2 <- sample(rep(0:2,c(round(n*.15),round(n*.15),n-2*round(n*.15))))
# subset rows by sample int 0-2 for train validate test
dat.train<-pew3[tvt2==2,]
dat.valid<-pew3[tvt2==1,]
dat.test<-pew3[tvt2==0,]
# create the null model
model.null <-glm(worse~1,data=dat.train,family="binomial")
# create formula for forward model selection (scope)
fwd_fmla <- as.formula(str_c("worse ~ ",
str_c(names(dat.train)[2:(ncol(dat.train))], collapse = "+")))
# sanity check
fwd_fmla
# create the model using automated forward selection
life.fwd <- step(model.null, scope = fwd_fmla, direction = "forward", trace = 1)
# create glm's
model.1 <- glm(worse~income,data=dat.train,family="binomial")
model.2 <- glm(worse~income+edu_factor,data=dat.train,family="binomial")
model.3 <- glm(worse~income+edu_factor+ideo_factor
,data=dat.train,family="binomial")
model.4 <- glm(worse~income+edu_factor+ideo_factor+gender_factor
,data=dat.train,family="binomial")
model.5 <- glm(worse~income+edu_factor+ideo_factor+gender_factor+reg4_factor
,data=dat.train,family="binomial")
model.6 <- glm(worse~income+edu_factor+ideo_factor+gender_factor+reg4_factor+
snsuse_factor
,data=dat.train,family="binomial")
model.7 <- glm(worse~income+edu_factor+ideo_factor+gender_factor+reg4_factor+
snsuse_factor+know_factor
,data=dat.train,family="binomial")
model.8 <- glm(worse~income+edu_factor+ideo_factor+gender_factor+reg4_factor+
snsuse_factor+know_factor+eth_factor
,data=dat.train,family="binomial")
# create valid.dev to calculate model deviance
valid.dev<-function(m.pred, dat.this){
pred.m<-predict(m.pred,dat.this, type="response")
-2*sum(dat.this$worse*log(pred.m)+(1-dat.this$worse)*log(1-pred.m))
}
# convert worse to numeric type for use with deviance function
dat.valid$worse <- as.numeric(as.character(dat.valid$worse))
# Your code for computing the validation-set deviances of each of the candidate models.
dev.1 <- valid.dev(model.1, dat.this = dat.valid)
dev.2 <- valid.dev(model.2, dat.this = dat.valid)
dev.3 <- valid.dev(model.3, dat.this = dat.valid)
dev.4 <- valid.dev(model.4, dat.this = dat.valid)
dev.5 <- valid.dev(model.5, dat.this = dat.valid)
dev.6 <- valid.dev(model.6, dat.this = dat.valid)
dev.7 <- valid.dev(model.7, dat.this = dat.valid)
dev.8 <- valid.dev(model.8, dat.this = dat.valid)
# print deviance for the candidate models
dev.1
dev.2
dev.3
dev.4
dev.5
dev.6
dev.7
dev.8
# convert worse to numeric type for use with deviance function
dat.test$worse <- as.numeric(as.character(dat.test$worse))
# compute deviance
test.dev <- valid.dev(model.3, dat.test)
# print deviance
test.dev
# convert worse back to factor
#dat.test$worse <- as.factor(dat.test$worse)
# create prediction
prediction <- predict(model.2,dat.test,type="response")
# binarize the outcome
prediction <- as.factor(ifelse(prediction > 0.5, 1, 0))
# create the confusion matrix using table function
confusion.matrix <- table(dat.test$worse, prediction,dnn=c("Actual","Predicted"))
# print the confusion matrix
confusion.matrix
# compute accuracy
# true positives and true negatives are on the diagonals
accuracy <- sum(diag(confusion.matrix))/sum(confusion.matrix)
# compute precision
# (true positive/(true positive + false positive))
precision <- confusion.matrix[2,2]/sum(confusion.matrix[,2])
# compute recall
# (true positive/(true positive + false negative)
recall <- confusion.matrix[2,2]/sum(confusion.matrix[2,])
# compute F1 score
F1 <- 2*((precision*recall)/(precision+recall))
knitr::opts_chunk$set(echo = TRUE)
# Load necessary libraries
library(tidyverse)
load("pew_data.RData")
pew2<-dplyr::select(dat,AGE,PPREG4,PPWORK,PPINCIMP,PPGENDER,PPETHM,IDEO,PPEDUCAT,LIFE, KNOWLEDGE,ENJOY,SNSUSE,SNSFREQ)
attributes(pew2$SNSUSE)
table(pew2$SNSUSE, exclude = NULL) # Exclude argument allows for NAs to be displayed and counted
attributes(pew2$SNSFREQ)
table(pew2$SNSFREQ, exclude = NULL)
# create new column using dplyr
pew2 <- pew2 %>%
mutate(SNSFREQ_recoded = ifelse(SNSUSE == 2 & is.na(SNSFREQ),
6 , SNSFREQ))
# original column
table(pew2$SNSFREQ, exclude = NULL)
# transformed column
table(pew2$SNSFREQ_recoded, exclude = NULL)
# create new data set
pew.start <- dplyr::select(pew2, LIFE,SNSUSE,SNSFREQ_recoded,PPREG4,
PPWORK, PPINCIMP,PPGENDER,PPETHM,IDEO,
PPEDUCAT, KNOWLEDGE, ENJOY, AGE)
# print the number of rows in pew.start
nrow(pew.start)
# check the LIFE Variable
attributes(pew.start$LIFE)
table(pew.start$LIFE, exclude = NULL)
# check the SNSUSE variable
attributes(pew.start$SNSUSE)
table(pew.start$SNSUSE, exclude = NULL)
# check the SNSFRQ_recoded variable
#attributes(pew.start$SNSFREQ)
table(pew.start$SNSFREQ_recoded, exclude = NULL)
# check the PPREG4 Variable
attributes(pew.start$PPREG4)
table(pew.start$PPREG4, exclude = NULL)
# check the PPPWORK variable
attributes(pew.start$PPWORK)
table(pew.start$PPWORK, exclude = NULL)
# check the PPINCIMP variable
attributes(pew.start$PPINCIMP)
table(pew.start$PPINCIMP, exclude = NULL)
# check the PPGENDER variable
attributes(pew.start$PPGENDER)
table(pew.start$PPGENDER, exclude = NULL)
# Check the PPETHM variable
attributes(pew.start$PPETHM)
table(pew.start$PPETHM, exclude = NULL)
# check the IDEO variable
attributes(pew.start$IDEO)
table(pew.start$IDEO, exclude = NULL)
# check the PPEDUCAT variable
attributes(pew.start$PPEDUCAT)
table(pew.start$PPEDUCAT, exclude = NULL)
# check the KNOWLEDGE variable
attributes(pew.start$KNOWLEDGE)
table(pew.start$KNOWLEDGE, exclude = NULL)
# check the ENJOY variable
attributes(pew.start$ENJOY)
table(pew.start$ENJOY, exclude = NULL)
# check the AGE variable
attributes(pew.start$AGE)
table(pew.start$AGE, exclude = NULL)
# set -1 and -2  equal to "NA"
pew.start[pew.start == -1| pew.start == -2] <- NA
# drop rows with "NA"
pew.start <- pew.start %>% drop_na()
# count rows in pew.start
nrow(pew.start)
# THE CORRECTION: I'm filling in this code chunk for you to ensure that you have the outcome in a form that will work for both the logistic regression models and the deviance computation you will do in Question 7. Run this chunk as it is.
pew.start$worse[pew.start$LIFE==1] <- 0
pew.start$worse[pew.start$LIFE==3] <- 0
pew.start$worse[pew.start$LIFE==2] <- 1
# display the frequencies of the original and recoded outcome
table(pew.start$LIFE, exclude = NULL)
table(pew.start$worse, exclude = NULL)
# re-code variables
#pew.start$worse <- as.factor(pew.start$worse)
pew.start$age    <- as.numeric(pew.start$AGE)
pew.start$income  <- as.numeric(pew.start$PPINCIMP)
pew.start$reg4_factor <- as.factor(pew.start$PPREG4)
pew.start$work_factor <- as.factor(pew.start$PPWORK)
pew.start$gender_factor <- as.factor(pew.start$PPGENDER)
pew.start$eth_factor <- as.factor(pew.start$PPETHM)
pew.start$ideo_factor <- as.factor(pew.start$IDEO)
pew.start$edu_factor <- as.factor(pew.start$PPEDUCAT)
pew.start$know_factor <- as.factor(pew.start$KNOWLEDGE)
pew.start$enjoy_factor <- as.factor(pew.start$ENJOY)
pew.start$snsuse_factor <- as.factor(pew.start$SNSUSE)
pew.start$snsfreqrecode_factor <- as.factor(pew.start$SNSFREQ_recoded)
# check data structure
str(pew.start)
# create new dataframe for analysis
pew3 <- dplyr::select(pew.start, worse, age, income, reg4_factor, work_factor,             gender_factor, eth_factor, ideo_factor, edu_factor, know_factor,
enjoy_factor, snsuse_factor, snsfreqrecode_factor)
# print data structure
str(pew3)
# save the number of rows in pew3
n <- nrow(pew3)
# set seed (reproducable)
set.seed(123456)
Sixty.twenty.twenty <- rep(0:2,c(round(n*.2),round(n*.2),n-2*round(n*.2)))
table(Sixty.twenty.twenty)
Seventy.fifteen.fifteen <- rep(0:2,c(round(n*.15),round(n*.15),n-2*round(n*.15)))
table(Seventy.fifteen.fifteen)
Eighty.ten.ten <- rep(0:2,c(round(n*.10),round(n*.10),n-2*round(n*.10)))
table(Eighty.ten.ten)
Ninety.five.five <- rep(0:2,c(round(n*.05),round(n*.05),n-2*round(n*.05)))
table(Ninety.five.five)
# create random sample of int 0-2, proportions 70, 15, 15
tvt2 <- sample(rep(0:2,c(round(n*.15),round(n*.15),n-2*round(n*.15))))
# subset rows by sample int 0-2 for train validate test
dat.train<-pew3[tvt2==2,]
dat.valid<-pew3[tvt2==1,]
dat.test<-pew3[tvt2==0,]
# create the null model
model.null <-glm(worse~1,data=dat.train,family="binomial")
# create formula for forward model selection (scope)
fwd_fmla <- as.formula(str_c("worse ~ ",
str_c(names(dat.train)[2:(ncol(dat.train))], collapse = "+")))
# sanity check
fwd_fmla
# create the model using automated forward selection
life.fwd <- step(model.null, scope = fwd_fmla, direction = "forward", trace = 1)
# create glm's
model.1 <- glm(worse~income,data=dat.train,family="binomial")
model.2 <- glm(worse~income+edu_factor,data=dat.train,family="binomial")
model.3 <- glm(worse~income+edu_factor+ideo_factor
,data=dat.train,family="binomial")
model.4 <- glm(worse~income+edu_factor+ideo_factor+gender_factor
,data=dat.train,family="binomial")
model.5 <- glm(worse~income+edu_factor+ideo_factor+gender_factor+reg4_factor
,data=dat.train,family="binomial")
model.6 <- glm(worse~income+edu_factor+ideo_factor+gender_factor+reg4_factor+
snsuse_factor
,data=dat.train,family="binomial")
model.7 <- glm(worse~income+edu_factor+ideo_factor+gender_factor+reg4_factor+
snsuse_factor+know_factor
,data=dat.train,family="binomial")
model.8 <- glm(worse~income+edu_factor+ideo_factor+gender_factor+reg4_factor+
snsuse_factor+know_factor+eth_factor
,data=dat.train,family="binomial")
# create valid.dev to calculate model deviance
valid.dev<-function(m.pred, dat.this){
pred.m<-predict(m.pred,dat.this, type="response")
-2*sum(dat.this$worse*log(pred.m)+(1-dat.this$worse)*log(1-pred.m))
}
# convert worse to numeric type for use with deviance function
dat.valid$worse <- as.numeric(as.character(dat.valid$worse))
# Your code for computing the validation-set deviances of each of the candidate models.
dev.1 <- valid.dev(model.1, dat.this = dat.valid)
dev.2 <- valid.dev(model.2, dat.this = dat.valid)
dev.3 <- valid.dev(model.3, dat.this = dat.valid)
dev.4 <- valid.dev(model.4, dat.this = dat.valid)
dev.5 <- valid.dev(model.5, dat.this = dat.valid)
dev.6 <- valid.dev(model.6, dat.this = dat.valid)
dev.7 <- valid.dev(model.7, dat.this = dat.valid)
dev.8 <- valid.dev(model.8, dat.this = dat.valid)
# print deviance for the candidate models
dev.1
dev.2
dev.3
dev.4
dev.5
dev.6
dev.7
dev.8
# convert worse to numeric type for use with deviance function
dat.test$worse <- as.numeric(as.character(dat.test$worse))
# compute deviance
test.dev <- valid.dev(model.3, dat.test)
# print deviance
test.dev
# convert worse back to factor
#dat.test$worse <- as.factor(dat.test$worse)
# create prediction
prediction <- predict(model.2,dat.test,type="response")
# binarize the outcome
prediction <- as.factor(ifelse(prediction > 0.5, 1, 0))
# create the confusion matrix using table function
confusion.matrix <- table(dat.test$worse, prediction,dnn=c("Actual","Predicted"))
# print the confusion matrix
confusion.matrix
# compute accuracy
# true positives and true negatives are on the diagonals
accuracy <- sum(diag(confusion.matrix))/sum(confusion.matrix)
# compute precision
# (true positive/(true positive + false positive))
precision <- confusion.matrix[2,2]/sum(confusion.matrix[,2])
# compute recall
# (true positive/(true positive + false negative)
recall <- confusion.matrix[2,2]/sum(confusion.matrix[2,])
# compute F1 score
F1 <- 2*((precision*recall)/(precision+recall))
getwd()
