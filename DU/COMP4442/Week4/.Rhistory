varnames <- attr(subsetsBoolean, "dimnames")[[2]]
varnames
# display the variables in best
varnames[subsets[best.subset.bic,]]
# pull dimension (variable) names from the model
varnames <- attr(subsetsBoolean, "dimnames")[[2]]
# display the variables in best
varnames[subsetsBoolean[best.subset.bic,]]
# pull dimension (variable) names from the model
varnames <- attr(subsetsBoolean, "dimnames")[[2]]
# display the variables in best
best.varnames[subsetsBoolean[best.subset.bic,]]
# display the variables in best
best.varnames <- varnames[subsetsBoolean[best.subset.bic,]]
best.varnames
# create model using formula displayed above
best.lm.bic <- lm(logTotHg ~ fishpart_factor + weight, data=fish.auto)
# print the model summary
summary(best.lm.bic)
# quick visual of BIC for each subset size
qplot(1:length(summary(best)$bic),summary(best)$bic)
# pick the model with the lowest BIC from "best"
# min function searches BIC's and returns the model number model with lowestBIC
best.subset.bic <- which(summary(best)$bic==min(summary(best)$bic))[1]
# pull dimension (variable) names from the model
varnames <- attr(subsetsBoolean, "dimnames")[[2]]
# display the variables in best
best.varnames <- varnames[subsetsBoolean[best.subset.bic,]]
# print variables
best.varnames
# create model using formula displayed above
best.lm.bic <- lm(logTotHg ~ fishpart_factor + weight, data=fish.auto)
# print the model summary
summary(best.lm.bic)
# quick visual of BIC for each subset size
qplot(1:length(summary(best)$bic),summary(best)$bic)
# pick the model with the lowest BIC from "best"
# min function searches BIC's and returns the model number model with lowest BIC
best.subset.bic <- which(summary(best)$bic==min(summary(best)$bic))[1]
# pull dimension (variable) names from the model
varnames <- attr(subsetsBoolean, "dimnames")[[2]]
# display the variables in best
best.varnames <- varnames[subsetsBoolean[best.subset.bic,]]
# print variables
best.varnames
# create model using variables displayed above
best.lm.bic <- lm(logTotHg ~ fishpart_factor + weight, data=fish.auto)
# print the model summary
summary(best.lm.bic)
# get bic's
bic <- summary(best)$bic
#  fitted predictors plus intercept and variance
q <- 1:length(bic)+2
# get the number of observations
n <- nrow(fish.auto)
# calculate Akaike information criterion
aic <- bic-log(n)*q+2*q
# get bic's
bic <- summary(best)$bic
#  fitted predictors plus intercept and variance
q <- 1:length(bic)+2
# get the number of observations
n <- nrow(fish.auto)
# calculate Akaike information criterion
aic <- bic-log(n)*q+2*q
# extract best subset based on Akaike information criteria
best.subset.aic <- which(aic == min(aic))[1]
# pull model parameters
params <- varnames[subsets[best.subset.aic,]]
# pull model parameters
best.varnames.aic <- varnames[subsetsBoolean[best.subset.aic,]]
best.varnames.aic
summary(best.subset.aic)
summary(best.subset.aic)
# quick visual of AIC
qplot(1:length(AICs),AICs)
# quick visual of AIC
qplot(1:length(aic),aic)
# extract best subset based on Akaike information criteria
best.subset.aic <- which(aic == min(aic))[1]
summary(best.subset.aic)
best.subset.aic
# pull model parameters
best.varnames.aic <- varnames[subsetsBoolean[best.subset.aic,]]
best.varnames.aic
varnames[subsetsBoolean[best.subset.aic,]]
# extract best subset based on Akaike information criteria
best.subset.aic <- which(aic == min(aic))[1]
best.subset.aic
# extract best subset based on Akaike information criteria
best.subset.aic <- which(aic == min(aic))[1]
# pull model parameters using subsetsBoolean since
# this works since both aic and bic criteria produced the same model in this case
best.varnames.aic <- varnames[subsetsBoolean[best.subset.aic,]]
# print the variable names
best.varnames.aic
# create the model using the formula for best aic determined above
summary(best.lm.aic)
# extract best subset based on Akaike information criteria
best.subset.aic <- which(aic == min(aic))[1]
# pull model parameters using subsetsBoolean since
# this works since both aic and bic criteria produced the same model in this case
best.varnames.aic <- varnames[subsetsBoolean[best.subset.aic,]]
# print the variable names
best.varnames.aic
# create the model using the formula for best aic determined above
best.lm.aic <- lm(logTotHg ~ fishpart_factor+weight, data=fish.auto)
summary(best.lm.aic)
# extract best subset based on Akaike information criteria
best.subset.aic <- which(aic == min(aic))[1]
# pull model parameters using subsetsBoolean since
# this works since both aic and bic criteria produced the same model in this case
best.varnames.aic <- varnames[subsetsBoolean[best.subset.aic,]]
# since the same model is produced we can also leverage one of the tables above
subsetsStar
# print the variable names
best.varnames.aic
# create the model using the formula for best aic determined above
best.lm.aic <- lm(logTotHg ~ fishpart_factor+weight, data=fish.auto)
summary(best.lm.aic)
# Load required packages
library(ggpubr)
library(leaps)
library(tidyverse)
library(stringr)
doughnuts.factorial <- read.csv("doughnutsfactorial.csv", header=TRUE, sep=",") # Loads the CSV file into memory. You may need to adapt this line to work on your computer
# Transform fat_type and flour_type
doughnuts.factorial$fat_type_factor <- as.factor(doughnuts.factorial$fat_type)
doughnuts.factorial$flour_type_factor <- as.factor(doughnuts.factorial$flour_type)
# check the structure of the data set
str(doughnuts.factorial)
# create the null (intercept only) model
model.null <- lm(sim_tot_fat ~ 1, data=doughnuts.factorial)
# print model summary
summary(model.null)
# create the fat_type model
model.fatType <- lm(sim_tot_fat ~ fat_type_factor, data=doughnuts.factorial)
# print the model summary
summary(model.fatType)
# create the model for flour_type
model.flourType <- lm(sim_tot_fat ~ flour_type_factor, data=doughnuts.factorial)
# print model
summary(model.flourType)
# nested model test, compare fat_type model to null model
anova(model.null, model.fatType)
# compare the flour_type model to the the null model
anova(model.null, model.flourType)
# create the main model
model.main <- lm(sim_tot_fat ~ fat_type_factor + flour_type_factor,
data=doughnuts.factorial)
# print model summary
summary(model.main)
# create the full model with interaction
model.interaction <- lm(sim_tot_fat ~ fat_type_factor*flour_type_factor,
data=doughnuts.factorial)
# pritn model summary
summary(model.interaction)
# nested model test for interaction effect
anova(model.main, model.interaction)
doughnuts.fat = aov(sim_tot_fat ~ fat_type_factor, data=doughnuts.factorial)
summary(doughnuts.fat)
doughnuts.flour = aov(sim_tot_fat ~ flour_type_factor, data=doughnuts.factorial)
summary(doughnuts.flour )
doughnuts.fact.2aov = aov(sim_tot_fat ~ fat_type_factor + flour_type_factor + fat_type_factor*flour_type_factor, data=doughnuts.factorial)
summary(doughnuts.fact.2aov)
fish <- read.csv("fishermen_mercury.csv", header=TRUE, sep=",") # Loads the CSV file into memory. You may need to adapt this line to work on your computer
# transform fishpart and fisherman to categorical variables
fish$fisherman_factor <- as.factor(fish$fisherman)
fish$fishpart_factor <- as.factor(fish$fishpart)
# check the structure of the data
str(fish)
# take natural log of totHg
fish$logTotHg <- log(fish$TotHg)
# create new dataset with for automated model selection
fish.auto <- select(fish, fisherman_factor, fishpart_factor, age, restime, height, weight, fishmlwk, logTotHg)
# check the data structure
str(fish.auto)
# create formula for forward model selection
fwd_fmla <- as.formula(str_c("logTotHg ~ ",
str_c(names(fish.auto)[1:(ncol(fish.auto)-1)], collapse = "+")))
# print formula
fwd_fmla
# create the model using automated forward selection
fish.fwd <- step(lm(logTotHg ~1, data=fish.auto), scope = fwd_fmla,
direction = "forward", trace = 1)
# print summary  of fish.fwd model
summary(fish.fwd)
# create formula for forward model selection
bwd_fmla <- as.formula(str_c("logTotHg ~ ",
str_c(names(fish.auto)[1:(ncol(fish.auto)-1)], collapse = "+")))
# create bwd_scope
bwd_scope <- as.formula("logTotHg ~1")
# sanity check
bwd_fmla
bwd_scope
# create the model using automated forward selection
fish.bwd <- step(lm(bwd_fmla, data=fish.auto), scope = bwd_scope,
direction = "backward", trace = 1)
# print model summary
summary(fish.bwd)
# create the model matrix "x"
x <- model.matrix(as.formula(str_c("logTotHg ~",
str_c(names(fish.auto)[1:ncol(fish.auto)-1],
collapse = "+"))),fish.auto)
# create the vector of outcomes
y <- fish.auto$logTotHg
# calculate the best subset of variables - removing (intercept)
best <- regsubsets(x=x[,2:ncol(x)], y=y, method = "exhaustive", nvmax = 9, nbest=1)
# create the TRUE/FALSE table for the best model
subsetsBoolean <- summary(best)$which
subsetsBoolean
# display the star table of the best subsets model
subsetsStar <- summary(best)
subsetsStar
# quick visual of BIC for each subset size
qplot(1:length(summary(best)$bic),summary(best)$bic)
# pick the model with the lowest BIC from "best"
# min function searches BIC's and returns the model number model with lowest BIC
best.subset.bic <- which(summary(best)$bic==min(summary(best)$bic))[1]
# pull dimension (variable) names from the model based TRUE/FALSE
varnames <- attr(subsetsBoolean, "dimnames")[[2]]
# display the variables in best
best.varnames <- varnames[subsetsBoolean[best.subset.bic,]]
# print variables
best.varnames
# create model using variables displayed above
best.lm.bic <- lm(logTotHg ~ fishpart_factor + weight, data=fish.auto)
# print the model summary
summary(best.lm.bic)
# get bic's
bic <- summary(best)$bic
#  fitted predictors plus intercept and variance
q <- 1:length(bic)+2
# get the number of observations
n <- nrow(fish.auto)
# calculate Akaike information criterion
aic <- bic-log(n)*q+2*q
# quick visual of aic
qplot(1:length(aic),aic)
# extract best subset based on Akaike information criteria
best.subset.aic <- which(aic == min(aic))[1]
# pull model parameters using subsetsBoolean since
# this works since both aic and bic criteria produced the same model in this case
best.varnames.aic <- varnames[subsetsBoolean[best.subset.aic,]]
# since the same model is produced we can also leverage one of the tables above
subsetsStar
# print the variable names
best.varnames.aic
# create the model using the formula for best aic determined above
best.lm.aic <- lm(logTotHg ~ fishpart_factor+weight, data=fish.auto)
summary(best.lm.aic)
# Load required packages
library(ggpubr)
library(leaps)
library(tidyverse)
library(stringr)
doughnuts.factorial <- read.csv("doughnutsfactorial.csv", header=TRUE, sep=",") # Loads the CSV file into memory. You may need to adapt this line to work on your computer
# Transform fat_type and flour_type
doughnuts.factorial$fat_type_factor <- as.factor(doughnuts.factorial$fat_type)
doughnuts.factorial$flour_type_factor <- as.factor(doughnuts.factorial$flour_type)
# check the structure of the data set
str(doughnuts.factorial)
# create the null (intercept only) model
model.null <- lm(sim_tot_fat ~ 1, data=doughnuts.factorial)
# print model summary
summary(model.null)
# create the fat_type model
model.fatType <- lm(sim_tot_fat ~ fat_type_factor, data=doughnuts.factorial)
# print the model summary
summary(model.fatType)
# create the model for flour_type
model.flourType <- lm(sim_tot_fat ~ flour_type_factor, data=doughnuts.factorial)
# print model
summary(model.flourType)
# nested model test, compare fat_type model to null model
anova(model.null, model.fatType)
# compare the flour_type model to the the null model
anova(model.null, model.flourType)
# create the main model
model.main <- lm(sim_tot_fat ~ fat_type_factor + flour_type_factor,
data=doughnuts.factorial)
# print model summary
summary(model.main)
# create the full model with interaction
model.interaction <- lm(sim_tot_fat ~ fat_type_factor*flour_type_factor,
data=doughnuts.factorial)
# pritn model summary
summary(model.interaction)
# nested model test for interaction effect
anova(model.main, model.interaction)
doughnuts.fat = aov(sim_tot_fat ~ fat_type_factor, data=doughnuts.factorial)
summary(doughnuts.fat)
doughnuts.flour = aov(sim_tot_fat ~ flour_type_factor, data=doughnuts.factorial)
summary(doughnuts.flour )
doughnuts.fact.2aov = aov(sim_tot_fat ~ fat_type_factor + flour_type_factor + fat_type_factor*flour_type_factor, data=doughnuts.factorial)
summary(doughnuts.fact.2aov)
fish <- read.csv("fishermen_mercury.csv", header=TRUE, sep=",") # Loads the CSV file into memory. You may need to adapt this line to work on your computer
# transform fishpart and fisherman to categorical variables
fish$fisherman_factor <- as.factor(fish$fisherman)
fish$fishpart_factor <- as.factor(fish$fishpart)
# check the structure of the data
str(fish)
# take natural log of totHg
fish$logTotHg <- log(fish$TotHg)
# create new dataset with for automated model selection
fish.auto <- select(fish, fisherman_factor, fishpart_factor, age, restime, height, weight, fishmlwk, logTotHg)
# check the data structure
str(fish.auto)
# create formula for forward model selection
fwd_fmla <- as.formula(str_c("logTotHg ~ ",
str_c(names(fish.auto)[1:(ncol(fish.auto)-1)], collapse = "+")))
# print formula
fwd_fmla
# create the model using automated forward selection
fish.fwd <- step(lm(logTotHg ~1, data=fish.auto), scope = fwd_fmla,
direction = "forward", trace = 1)
# print summary  of fish.fwd model
summary(fish.fwd)
# create formula for forward model selection
bwd_fmla <- as.formula(str_c("logTotHg ~ ",
str_c(names(fish.auto)[1:(ncol(fish.auto)-1)], collapse = "+")))
# create bwd_scope
bwd_scope <- as.formula("logTotHg ~1")
# sanity check
bwd_fmla
bwd_scope
# create the model using automated forward selection
fish.bwd <- step(lm(bwd_fmla, data=fish.auto), scope = bwd_scope,
direction = "backward", trace = 1)
# print model summary
summary(fish.bwd)
# create the model matrix "x"
x <- model.matrix(as.formula(str_c("logTotHg ~",
str_c(names(fish.auto)[1:ncol(fish.auto)-1],
collapse = "+"))),fish.auto)
# create the vector of outcomes
y <- fish.auto$logTotHg
# calculate the best subset of variables - removing (intercept)
best <- regsubsets(x=x[,2:ncol(x)], y=y, method = "exhaustive", nvmax = 9, nbest=1)
# create the TRUE/FALSE table for the best model
subsetsBoolean <- summary(best)$which
subsetsBoolean
# display the star table of the best subsets model
subsetsStar <- summary(best)
subsetsStar
# quick visual of BIC for each subset size
qplot(1:length(summary(best)$bic),summary(best)$bic)
# pick the model with the lowest BIC from "best"
# min function searches BIC's and returns the model number model with lowest BIC
best.subset.bic <- which(summary(best)$bic==min(summary(best)$bic))[1]
# pull dimension (variable) names from the model based TRUE/FALSE
varnames <- attr(subsetsBoolean, "dimnames")[[2]]
# display the variables in best
best.varnames <- varnames[subsetsBoolean[best.subset.bic,]]
# print variables
best.varnames
# create model using variables displayed above
best.lm.bic <- lm(logTotHg ~ fishpart_factor + weight, data=fish.auto)
# print the model summary
summary(best.lm.bic)
# get bic's
bic <- summary(best)$bic
#  fitted predictors plus intercept and variance
q <- 1:length(bic)+2
# get the number of observations
n <- nrow(fish.auto)
# calculate Akaike information criterion
aic <- bic-log(n)*q+2*q
# quick visual of aic
qplot(1:length(aic),aic)
# extract best subset based on Akaike information criteria
best.subset.aic <- which(aic == min(aic))[1]
# pull model parameters using subsetsBoolean since
# this works since both aic and bic criteria produced the same model in this case
best.varnames.aic <- varnames[subsetsBoolean[best.subset.aic,]]
# since the same model is produced we can also leverage one of the tables above
subsetsStar
# print the variable names
best.varnames.aic
# create the model using the formula for best aic determined above
best.lm.aic <- lm(logTotHg ~ fishpart_factor+weight, data=fish.auto)
summary(best.lm.aic)
# Load required packages
library(ggpubr)
library(leaps)
library(tidyverse)
library(stringr)
doughnuts.factorial <- read.csv("doughnutsfactorial.csv", header=TRUE, sep=",") # Loads the CSV file into memory. You may need to adapt this line to work on your computer
# Transform fat_type and flour_type
doughnuts.factorial$fat_type_factor <- as.factor(doughnuts.factorial$fat_type)
doughnuts.factorial$flour_type_factor <- as.factor(doughnuts.factorial$flour_type)
# check the structure of the data set
str(doughnuts.factorial)
# create the null (intercept only) model
model.null <- lm(sim_tot_fat ~ 1, data=doughnuts.factorial)
# print model summary
summary(model.null)
# create the fat_type model
model.fatType <- lm(sim_tot_fat ~ fat_type_factor, data=doughnuts.factorial)
# print the model summary
summary(model.fatType)
# create the model for flour_type
model.flourType <- lm(sim_tot_fat ~ flour_type_factor, data=doughnuts.factorial)
# print model
summary(model.flourType)
# nested model test, compare fat_type model to null model
anova(model.null, model.fatType)
# compare the flour_type model to the the null model
anova(model.null, model.flourType)
# create the main model
model.main <- lm(sim_tot_fat ~ fat_type_factor + flour_type_factor,
data=doughnuts.factorial)
# print model summary
summary(model.main)
# create the full model with interaction
model.interaction <- lm(sim_tot_fat ~ fat_type_factor*flour_type_factor,
data=doughnuts.factorial)
# pritn model summary
summary(model.interaction)
# nested model test for interaction effect
anova(model.main, model.interaction)
doughnuts.fat = aov(sim_tot_fat ~ fat_type_factor, data=doughnuts.factorial)
summary(doughnuts.fat)
doughnuts.flour = aov(sim_tot_fat ~ flour_type_factor, data=doughnuts.factorial)
summary(doughnuts.flour )
doughnuts.fact.2aov = aov(sim_tot_fat ~ fat_type_factor + flour_type_factor + fat_type_factor*flour_type_factor, data=doughnuts.factorial)
summary(doughnuts.fact.2aov)
fish <- read.csv("fishermen_mercury.csv", header=TRUE, sep=",") # Loads the CSV file into memory. You may need to adapt this line to work on your computer
# transform fishpart and fisherman to categorical variables
fish$fisherman_factor <- as.factor(fish$fisherman)
fish$fishpart_factor <- as.factor(fish$fishpart)
# check the structure of the data
str(fish)
# take natural log of totHg
fish$logTotHg <- log(fish$TotHg)
# create new dataset with for automated model selection
fish.auto <- select(fish, fisherman_factor, fishpart_factor, age, restime, height, weight, fishmlwk, logTotHg)
# check the data structure
str(fish.auto)
# create formula for forward model selection
fwd_fmla <- as.formula(str_c("logTotHg ~ ",
str_c(names(fish.auto)[1:(ncol(fish.auto)-1)], collapse = "+")))
# print formula
fwd_fmla
# create the model using automated forward selection
fish.fwd <- step(lm(logTotHg ~1, data=fish.auto), scope = fwd_fmla,
direction = "forward", trace = 1)
# print summary  of fish.fwd model
summary(fish.fwd)
# create formula for forward model selection
bwd_fmla <- as.formula(str_c("logTotHg ~ ",
str_c(names(fish.auto)[1:(ncol(fish.auto)-1)], collapse = "+")))
# create bwd_scope
bwd_scope <- as.formula("logTotHg ~1")
# sanity check
bwd_fmla
bwd_scope
# create the model using automated forward selection
fish.bwd <- step(lm(bwd_fmla, data=fish.auto), scope = bwd_scope,
direction = "backward", trace = 1)
# print model summary
summary(fish.bwd)
# create the model matrix "x"
x <- model.matrix(as.formula(str_c("logTotHg ~",
str_c(names(fish.auto)[1:ncol(fish.auto)-1],
collapse = "+"))),fish.auto)
# create the vector of outcomes
y <- fish.auto$logTotHg
# calculate the best subset of variables - removing (intercept)
best <- regsubsets(x=x[,2:ncol(x)], y=y, method = "exhaustive", nvmax = 9, nbest=1)
# create the TRUE/FALSE table for the best model
subsetsBoolean <- summary(best)$which
subsetsBoolean
# display the star table of the best subsets model
subsetsStar <- summary(best)
subsetsStar
# quick visual of BIC for each subset size
qplot(1:length(summary(best)$bic),summary(best)$bic)
# pick the model with the lowest BIC from "best"
# min function searches BIC's and returns the model number model with lowest BIC
best.subset.bic <- which(summary(best)$bic==min(summary(best)$bic))[1]
# pull dimension (variable) names from the model based TRUE/FALSE
varnames <- attr(subsetsBoolean, "dimnames")[[2]]
# display the variables in best
best.varnames <- varnames[subsetsBoolean[best.subset.bic,]]
# print variables
best.varnames
# create model using variables displayed above
best.lm.bic <- lm(logTotHg ~ fishpart_factor + weight, data=fish.auto)
# print the model summary
summary(best.lm.bic)
# get bic's
bic <- summary(best)$bic
#  fitted predictors plus intercept and variance
q <- 1:length(bic)+2
# get the number of observations
n <- nrow(fish.auto)
# calculate Akaike information criterion
aic <- bic-log(n)*q+2*q
# quick visual of aic
qplot(1:length(aic),aic)
# extract best subset based on Akaike information criteria
best.subset.aic <- which(aic == min(aic))[1]
# pull model parameters using subsetsBoolean since
best.varnames.aic <- varnames[subsetsBoolean[best.subset.aic,]]
# since the same model is produced we can also leverage one of the tables above
subsetsStar
# print the variable names
best.varnames.aic
# create the model using the formula for best aic determined above
best.lm.aic <- lm(logTotHg ~ fishpart_factor+weight, data=fish.auto)
summary(best.lm.aic)
